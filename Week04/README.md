# 学习笔记

## 字符串分析算法（从简单到难）
1. 字典树（大量高重复字符串的存储和分析）——精确的匹配字符串和模式（看一个字符串是不是能够两个字符串精确相等）
    eg：处理一亿个字符串里有多少（频率）前50数量的字符串，字符串海量的处理情况（搜索关键词）
2. KMP（K：高德纳）（在长字符串里找模式）——不是完整的字符串匹配算法，他是一个检查一个长字符串里面有没有一个短的字符串的部分的，部分匹配（两个字符串，一个字符串是另一个字符串的部分）
    eg：一个长度为m的字符串和一个为n的字符串，互相匹配。可以做到算法复杂度为m+n
3. Wildcard（带通配符的字符串模式）——在KMP的基础上加了通配符，只有两种通配符。？：匹配任意字符。*：匹配任意数量的任意字符（弱一点的正则）
    eg：文件查找。时间复杂度：O(n)或者O(m+n)
4. 正则（字符串通用模式匹配）——回溯的系统（字符串匹配的终极版本）
5. 状态机（通用的字符串分析）
6. LL LR语法分析的算法（字符串多层级分析）
7. 前5种都是字符串模式匹配，LR比LL更强大的语法分析（LR：HTML语法分析stack处理是LR算法的简化版——LR(0)的语法）一般会用LR(1)处理，LR(1)等于LL(n)

## 字典树
1. 

## KMP
1. 概念：字符串模式匹配算法（模式匹配：查一个字符串里有没有另一个字符串）有一个原串：待查的串
比较短的pattern串（在长串里面找的比较短的字符串）
2. 解决的问题：在长串里面找的比较短的字符串；
3. KMP匹配算法由来：最朴素的算法：Brute-Force（BF）——暴力解（从长的字符串的每一个节点开始看有没有匹配到pattern的串），时间复杂度是O(m*n);为了解决这个问题，发明了KMP算法；
4. KMP匹配算法：K——高德纳（Donald Ervin Knuth）计算机程序设计艺术的作者，M P当时比较著名的计算机专家；

## Wildcard
1. 

## 编程技巧
1. 拷贝

(1)
```
let pattern = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
let copy = JSON.parse(JSON.stringify(pattern))
```

## 问题记录
【问题】出现死循环

【原因】写代码不够仔细，对老师的讲解没有吃透。

【解决】写代码1小时，找错3小时。哎呀妈呀，脑瓜疼。

### 学习复盘
1. 没有安排足够的时间来学习，导致理解不足；
2. 对TicTacToe AI部分还没理解透彻；
3. async/await 课下加强练习；
4. 补全追溯法信息，时间仓促没好好整理；
5. 加强解偶功能函数的能力，否则代码一团糟，且维护成本高；
6. 避免眼高手低；
